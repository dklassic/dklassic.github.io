---
title: "APFramework UI 系統開發歷程"
date: 2025-06-03T16:32:01+08:00
draft: false
tags: ["遊戲設計"]
---

APFramework 是個我開發個人作品的時候使用的框架，AP 就是 Autopanic，沒有想太多就叫這名字了。但雖然說是框架，最初因為《自動混亂》是個完全依靠 Singleton method 在運作的練習作品，所以第一代的 APFramework 作品（最早的《自動混亂》與《自動混亂：零式》）與其說是用這個框架開發的，不如說是一堆膠帶捆起來的東西構成的。

不過在這一團亂中至少有一個系統被包裝得相當完整，到我覺得確實可以稱之為是個框架，那就是我開發的所有作品中都使用的 UI 系統。所以我想要寫一篇文來提一下這個介面系統開發的過程。

這篇文會照著實際的開發流程說明各個設計變化，因此中間會有一些過度設計未來可能已經解決的狀況。

# 緣起

既然是為了開發遊戲而開發的框架，當然就是為了解決很特定的開發需求而存在的，而第一個問題就是：人力不足。由於我的作品基本上都是我個人開發的，也就代表說我的開發量能無論再怎麼有效率，一定有對應的上限。這件事情最容易體現的地方就是介面的製作與調整很費時。

《自動混亂》在過去某個階段處於量產敵人的狀態，瞬間有大量要測試驗證的敵人行為。除了要測試個別的敵人以外，也需要測試不同敵人間的配合狀態，於是「要怎麼快速生成各種敵人配置」就成了一個議題，已經不是在 Inspector 暴露一個 bool 配 Update loop 偵測之類可以硬是解決的問題。這個議題也衍生出了幾個必須被解決的問題：

- 要用怎樣的使用體驗？
- 這個介面要長什麼樣子？
- 要允許什麼方式可以操作這個介面？
- 操作這個介面的體驗應該要長怎樣？

## 要用怎樣的使用體驗？

在這之前，我就曾經使用 UGUI 來做過一次介面，那時候使用的是普通的系統選單、解析度調整等等，當時覺得還好，就是元件掛一掛、拉好 Unity Event 註冊就行。不過這次的需求有一個明顯的不同：有多次變更與動態調整的需求。

普通的系統選單該有什麼選項大致上是固定的，開發期間偶爾會加入新的項目，但也就那樣。可是今天每新增一個敵人，我就要空出時間來先幫選單加入一個按鈕，是個顯著破壞迭代節奏的開發過程。於是確立了一件事：我需要一個架構上能讓我直接用在程式碼內寫少數幾行，就能自動生成出選單的機制。理想上我想要一個：

```
foreach Enemy in Enemies
{
    AddButton(Enemy, EnemyManager.Spawn(Enemy));
}
```

這種感覺就可以完成介面初始化的使用體驗，這樣未來無論增加多少東西，都可以一行解決它、甚至寫個 loop 解決。

## 這個介面要長什麼樣子？

在沒開發量能的情況下，我就確定我不能把心力放在刻製大量客製介面上，我需要一個平均堪用但也至少不會讓人覺得醜的介面，直接同時共用為開發除錯介面以及玩家實際上會看到的介面。

這時候我看到了一個[訪談了 Recompile 開發者的影片](https://youtu.be/Fz9CLNtENLg)，發現他們刻了一個很酷的 [ASCII Rendering Engine](https://github.com/pblca/PhiOS)，而《自動混亂》雖然一開始比較想要走輕科幻介面視覺，但樸實的純文字電腦風介面似乎也相當搭。

在經過一番調查後，可惜當時我不算有充裕的知識知道怎麼魔改這個引擎到可以正常使用，但在這基礎下我就決定大膽賭賭看怎樣仿製一套類似的介面系統。因此就定位好了：

- 幾乎完全自己刻的，不引用任何外部套件的介面系統
- 使用純文字顯示

使用 TMP 倒沒有太特別的理由，因為我也不知道有什麼其他選項。

而我也從這個 Rendering Engine 學到他的概念是「生成一個 X x Y 的方格空間」接著可以去操作這個空間內的顯示，因而被我延伸理解成是 Window 與其中的 WindowElement 的概念。

## 要允許什麼方式可以操作這個介面？

由於《自動混亂》是一個相當以手把為主開發的作品，手把要能操作是必然，而其實支援手把的同時要支援鍵盤也就很簡單。與此同時也做出了先不考慮支援滑鼠的決定，但主因是因為使用標準的 Unity 元件的話已經有官方原生做好的滑鼠偵測，而在這個階段我還沒有很好的概念要怎麼支援滑鼠。

此時的我頂多只想得出每個元件有一個位置，然後距離多近內判斷命中，但不知道要怎樣精準地判斷一個元件的範圍。

## 操作這個介面的體驗應該要長怎樣？

這時候就再次回到最一開始的用途：敵人組合設定並生成。因為這個因素，最一開始設計的兩個元件，第一個必然就是可以按下去觸發功能的 Button，第二個就是 Slider 畢竟設定數字來說是最直覺的。於是我做出了可以在指定整數範圍內滑動的 Slider，接著就可以讀取各元件的數值去生成敵人。

不過其實馬上就發現雖然這件事情很符合邏輯，流暢度卻很低：因為在我的設計下每一個 Slider 要先進入所謂的「輸入狀態」才能夠按左右鍵調整數值，接著又要退出「輸入狀態」才能夠退出。同時要生成複數種類敵人時，進出「輸入狀態」就顯得很冗餘，然而「輸入狀態」的概念本身又非常的合理，因為如果有兩個左右鄰近的視窗存在時，應該要有辦法在兩個視窗切換，而如果 Slider 要可以隨時都做增減值的話，就會干擾到這件事。

於是我做了一個所謂的 ButtonCountable，一個可以說是功能性接近 Slider，都是可以調整出一個數值，但是在這邊是用確認鍵與取消鍵操作增減。

至此構成了最基礎的介面。

![First iteration]()

# 開發歷程

## 各種視窗外框與轉換視覺效果

## 更多元件

## 滑鼠偵測

## 效能改善

### 字串 Concat

### 反覆重建問題

## 文字輸入

## 階級自動命名系統

## 泛用取值系統 

## 泛用狀態切換系統

## 泛型元件系統

## 純 Class 元件

## 泛用型跨視窗移動偵測邏輯

## 泛用性介面工具

### ConfirmationProvider

### ContextMenuProvider

## Builder 風格設定手段

## 非可互動元件標示

## 系統保護性措施

# 未來

## 視窗邏輯與 Presenter 抽離

## 實作中間層，讓 ZString 非必須化